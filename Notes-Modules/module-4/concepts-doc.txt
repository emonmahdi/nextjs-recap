✅ What is a Layout?
A layout is a UI structure shared across multiple pages, such as a header, sidebar, or footer. It is stateful and preserved between navigations.

✅ Why use Layouts?
Avoid repeating common UI elements.

Improve performance by reusing static layout parts.

Keep global state (e.g., user auth, theme toggle) intact.

app/
├── layout.tsx     ✅ Shared layout
├── page.tsx       ✅ Homepage
├── about/
│   └── page.tsx   ✅ About page

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <header>🌐 Site Header</header>
        <main>{children}</main>
        <footer>📍 Footer</footer>
      </body>
    </html>
  );
}


✅ What is a Template?
A template is like a layout but is not persistent. It re-renders on every navigation, useful when pages should not share state.

✅ Why use Templates?
Useful for modals, dynamic dashboards, or onboarding flows.

When you want to reset state on navigation.

Improves flexibility when layout reuse is not desired.

app/
├── dashboard/
│   ├── template.tsx   ✅ Unique template for dashboard
│   └── page.tsx


export default function DashboardTemplate({ children }: { children: React.ReactNode }) {
  console.log('Dashboard template rendered');

  return (
    <div style={{ border: '2px solid green', padding: '10px' }}>
      <h2>Dashboard Wrapper</h2>
      {children}
    </div>
  );
}

----------------------------
error.tsx – Route-level Error Handling
-----------------------------
✅ Why use error.tsx?
It allows you to handle errors locally, scoped to a specific route (e.g., /dashboard, /profile), without affecting the whole app.

app/
├── dashboard/
│   ├── error.tsx   ✅ Local error handler
│   └── page.tsx


📄 app/dashboard/error.tsx:

'use client';

export default function DashboardError({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <div style={{ color: 'red' }}>
      <h2>Something went wrong in Dashboard!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}


📄 app/dashboard/page.tsx:

'use client';

export default function DashboardPage() {
  throw new Error('This is a dashboard-specific error!');
  return <h1>Dashboard</h1>
}


https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary

---------------------------
global-error.tsx – App-level Error Handling 
---------------------------

✅ Why use global-error.tsx?
It handles unhandled or unexpected errors across the entire app that aren't scoped to a specific route (like 500s or internal crashes).

app/
├── global-error.tsx  ✅ Global error handler
├── layout.tsx
├── page.tsx


📄 app/global-error.tsx:

'use client';

export default function GlobalError({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <html>
      <body style={{ color: 'darkred', textAlign: 'center' }}>
        <h1>🔥 Global Error</h1>
        <p>{error.message}</p>
        <button onClick={() => reset()}>Try Again</button>
      </body>
    </html>
  );
}


📄 Anywhere in your app (page.tsx, etc):
'use client';

export default function HomePage() {
  throw new Error('Global error triggered from home page!');
}


---------------------
Parallel Routing explained
------------------------
✅ 1. What is a Parallel Route?

Parallel Routes allow multiple pages or layouts to be rendered at the same time in different parts of a web page, without replacing each other. Each route renders independently in its own UI region.

Parallel Routes আপনাকে একই লেআউটের মধ্যে একাধিক পেজ একসাথে বা নির্দিষ্ট শর্তে রেন্ডার করার সুযোগ দেয়। এটি অ্যাপের খুবই ডায়নামিক অংশগুলোর জন্য বিশেষভাবে উপযোগী, যেমন ড্যাশবোর্ড বা সোশ্যাল সাইটের ফিড ইত্যাদি।

2. Why Use Parallel Routes?

  - You want to display multiple route-based UI areas simultaneously (e.g., sidebar + chat + main content). 
  - You need nested UI sections controlled by different parts of the URL or state.
  - You want to build multi-panel dashboards, modals, or chat apps that update independently.

3. How to use: 

Parallel routes are created using named slots. Slots are defined with the @folder convention. For example, the following file structure defines two slots: @analytics and @team:

  Q1: What are parallel routes, and how do they differ from nested routes?
Answer: Parallel routes allow rendering multiple route-based components side-by-side independently. Nested routes are hierarchical — child routes render inside parent routes.

Q2: Give a use case where parallel routes are useful.
Answer: A messaging app: you can keep the inbox visible while navigating through different chat threads without replacing the whole UI.

Q3: How do parallel routes improve performance?
Answer: They avoid unnecessary re-renders or reloads of unrelated parts of the UI by isolating updates.

Q4: How are parallel routes implemented in Next.js 15 App Router?
Answer: Using @slot folders like @chat, @dashboard and rendering them through layout props.